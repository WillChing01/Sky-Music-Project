{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useReducer } from \"react\";\nimport { getDataByKeys } from \"../utility/fetchNapster\";\nconst initialState = {\n  items: [],\n  error: {\n    statusCode: null,\n    statusText: '',\n    userMsg: ''\n  },\n  pendingMsg: ''\n};\n\nconst getDelay = attempts => {\n  return Math.floor(2 ** attempts) * 1000;\n};\n\nconst DATA_LOADING = 'DATA_LOADING';\nconst ABOUT_TO_RETRY = 'ABOUT_TO_RETRY';\nconst DATA_RETRIEVED = 'DATA_RETRIEVED';\nconst ERROR = 'ERROR';\nconst INITIALISE = 'INITIALISE';\n\nconst dataReducer = (state, action) => {\n  switch (action.type) {\n    case DATA_LOADING:\n      return { ...initialState,\n        pendingMsg: 'Loading...'\n      };\n\n    case ABOUT_TO_RETRY:\n      return { ...initialState,\n        pendingMsg: `Fetch failed. ${action.payload.triesLeft} tries left. Retrying in ${action.payload.secsToRetry} seconds...`\n      };\n\n    case DATA_RETRIEVED:\n      return { ...initialState,\n        items: action.payload\n      };\n\n    case ERROR:\n      return { ...initialState,\n        error: action.payload\n      };\n\n    case INITIALISE:\n      return initialState;\n\n    default:\n      return state;\n  }\n};\n\nconst getUserErrMessage = err => {\n  if (err.status >= 500) {\n    return 'We couldn\\'t connect to the server.';\n  } else if (err.status === 404) {\n    return 'The resource could not be found.';\n  } else {\n    return 'There was a problem fetching the data.';\n  }\n};\n\nconst useFetch = function (url, keys) {\n  _s();\n\n  let deps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let fetchOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let totalFetchAttempts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 5;\n  const [state, dispatch] = useReducer(dataReducer, initialState);\n  let isCancelled = false;\n\n  const dispatchIfNotCancelled = action => {\n    if (!isCancelled) dispatch(action);\n  };\n\n  const dispatchAboutToRetry = (triesLeft, countdown) => {\n    dispatchIfNotCancelled({\n      type: ABOUT_TO_RETRY,\n      payload: {\n        triesLeft,\n        secsToRetry: countdown / 1000\n      }\n    });\n  };\n\n  const dispatchErr = err => {\n    dispatchIfNotCancelled({\n      type: ERROR,\n      payload: {\n        statusCode: err.status,\n        statusText: err.statusText,\n        userMsg: err.userMsg || getUserErrMessage(err)\n      }\n    });\n  };\n\n  const dispatchDataRetrieved = data => {\n    dispatchIfNotCancelled({\n      type: DATA_RETRIEVED,\n      payload: data\n    });\n  };\n\n  const waitForRetry = (triesLeft, delay) => {\n    return new Promise(resolve => {\n      let countdown = delay;\n      dispatchAboutToRetry(triesLeft, countdown);\n      const id = setInterval(() => {\n        countdown -= 1000;\n\n        if (countdown === 0) {\n          clearInterval(id);\n          resolve();\n        }\n\n        dispatchAboutToRetry(triesLeft, countdown);\n      }, 1000);\n    });\n  };\n\n  const fetchRetry = async tries => {\n    const handleFetchError = err => {\n      if (err.status >= 500) handleRetry(err);else dispatchErr(err);\n    };\n\n    const handleRetry = err => {\n      const triesLeft = tries - 1;\n      const attempts = totalFetchAttempts - triesLeft;\n      const delay = getDelay(attempts);\n\n      if (triesLeft === 0) {\n        dispatchErr(err);\n      } else {\n        waitForRetry(triesLeft, delay).then(() => fetchRetry(triesLeft));\n      }\n    };\n\n    dispatch({\n      type: DATA_LOADING\n    });\n    const res = await fetch(url, fetchOptions);\n\n    if (res.ok) {\n      const jRes = await res.json();\n      const data = getDataByKeys(jRes, keys);\n      dispatchDataRetrieved(data);\n    } else {\n      handleFetchError(res);\n    }\n  };\n\n  useEffect(() => {\n    /*\r\n     * The following is inferred from log statements: \r\n     * Suppose you are in React strict mode. Then, after useFetch has retured, and we have\r\n     * rendered for the first time:\r\n     * - the useEffect fires\r\n     * - the clean up function for this useEffect fires\r\n     * - isCancelled is set to true; and\r\n     * - the useEffect fires _again_ \r\n     * This second useEffect still reads vars native to the first render. So \r\n     * without setting isCancelled = false in the useEffect, fetchRetry would see \r\n     * isCancelled = true, and fail to make its dispatches. \r\n     */\n    isCancelled = false;\n    fetchRetry(totalFetchAttempts);\n    return () => {\n      isCancelled = true;\n      dispatch({\n        type: INITIALISE\n      });\n    };\n  }, deps);\n  return state;\n};\n\n_s(useFetch, \"bgCdjuTOmPdSBRwTap80EFd9Y3U=\");\n\nexport default useFetch;","map":{"version":3,"names":["useEffect","useReducer","getDataByKeys","initialState","items","error","statusCode","statusText","userMsg","pendingMsg","getDelay","attempts","Math","floor","DATA_LOADING","ABOUT_TO_RETRY","DATA_RETRIEVED","ERROR","INITIALISE","dataReducer","state","action","type","payload","triesLeft","secsToRetry","getUserErrMessage","err","status","useFetch","url","keys","deps","fetchOptions","totalFetchAttempts","dispatch","isCancelled","dispatchIfNotCancelled","dispatchAboutToRetry","countdown","dispatchErr","dispatchDataRetrieved","data","waitForRetry","delay","Promise","resolve","id","setInterval","clearInterval","fetchRetry","tries","handleFetchError","handleRetry","then","res","fetch","ok","jRes","json"],"sources":["C:/Users/adamg/Documents/temp/sky/Sky-Music-Project/my-app/src/hooks/useFetch.js"],"sourcesContent":["import { useEffect, useReducer } from \"react\";\r\nimport { getDataByKeys } from \"../utility/fetchNapster\";\r\n\r\nconst initialState =  {\r\n    items: [],\r\n    error: {\r\n      statusCode: null,\r\n      statusText: '',\r\n      userMsg: ''\r\n    },\r\n    pendingMsg: ''\r\n};\r\n\r\n\r\nconst getDelay = (attempts) => {\r\n    return Math.floor((2 ** attempts)) * 1000;\r\n};\r\n\r\nconst DATA_LOADING = 'DATA_LOADING';\r\nconst ABOUT_TO_RETRY = 'ABOUT_TO_RETRY';\r\nconst DATA_RETRIEVED = 'DATA_RETRIEVED';\r\nconst ERROR = 'ERROR';\r\nconst INITIALISE = 'INITIALISE';\r\n\r\nconst dataReducer = (state, action) => {\r\n    switch (action.type) {\r\n        case DATA_LOADING:\r\n            return {\r\n                ...initialState, \r\n                pendingMsg: 'Loading...'\r\n            };\r\n        case ABOUT_TO_RETRY:\r\n            return {\r\n                ...initialState, \r\n                pendingMsg: `Fetch failed. ${action.payload.triesLeft} tries left. Retrying in ${action.payload.secsToRetry} seconds...`\r\n            };\r\n        case DATA_RETRIEVED:\r\n            return {\r\n                ...initialState, \r\n                items: action.payload\r\n            }\r\n        case ERROR:\r\n            return {\r\n                ...initialState,\r\n                error: action.payload\r\n            };\r\n        case INITIALISE:\r\n            return initialState;\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\nconst getUserErrMessage = (err) => {\r\n    if (err.status >= 500) {\r\n          return 'We couldn\\'t connect to the server.';\r\n    } else if (err.status === 404) {\r\n          return 'The resource could not be found.';\r\n    } else {\r\n          return 'There was a problem fetching the data.';\r\n    }\r\n};\r\n\r\n\r\nconst useFetch = (url, keys, deps = [], fetchOptions = {}, totalFetchAttempts = 5) => {\r\n    const [state, dispatch] = useReducer(dataReducer, initialState);\r\n    let isCancelled = false;\r\n\r\n    const dispatchIfNotCancelled = (action) => {\r\n        if (!isCancelled) dispatch(action);\r\n    };\r\n\r\n    const dispatchAboutToRetry = (triesLeft, countdown) => {\r\n        dispatchIfNotCancelled({\r\n            type: ABOUT_TO_RETRY, \r\n            payload: {\r\n                triesLeft,\r\n                secsToRetry: countdown / 1000\r\n            }\r\n        });\r\n    };\r\n\r\n    const dispatchErr = (err) => {\r\n        dispatchIfNotCancelled({\r\n            type: ERROR,\r\n            payload: {\r\n                statusCode: err.status,\r\n                statusText: err.statusText,\r\n                userMsg: err.userMsg || getUserErrMessage(err)\r\n            }\r\n        });\r\n    };\r\n\r\n    const dispatchDataRetrieved = (data) => {\r\n        dispatchIfNotCancelled({\r\n            type: DATA_RETRIEVED,\r\n            payload: data\r\n        });\r\n    };\r\n\r\n\r\n    const waitForRetry = (triesLeft, delay) => {\r\n        return new Promise((resolve) => {\r\n            let countdown = delay;\r\n            dispatchAboutToRetry(triesLeft, countdown);\r\n            const id = setInterval(() => {\r\n                countdown -= 1000;\r\n                if (countdown === 0) {\r\n                    clearInterval(id);\r\n                    resolve();\r\n                }\r\n               dispatchAboutToRetry(triesLeft, countdown);\r\n            }, 1000);\r\n            \r\n        });\r\n    };\r\n\r\n    const fetchRetry = async (tries)  => {\r\n        const handleFetchError = (err) => {\r\n           if (err.status >= 500) handleRetry(err);\r\n           else dispatchErr(err);\r\n        };\r\n\r\n        const handleRetry = (err) => {\r\n            const triesLeft = tries - 1;\r\n            const attempts = totalFetchAttempts - triesLeft;\r\n            const delay = getDelay(attempts);\r\n            if (triesLeft === 0) {\r\n                dispatchErr(err); \r\n            } else {\r\n                waitForRetry(triesLeft, delay)\r\n                .then(() => fetchRetry(triesLeft))\r\n            }\r\n        };\r\n\r\n        dispatch({\r\n            type: DATA_LOADING\r\n        });\r\n        const res = await fetch(url, fetchOptions);\r\n        if (res.ok) {\r\n            const jRes = await res.json();\r\n            const data = getDataByKeys(jRes, keys);\r\n            dispatchDataRetrieved(data);\r\n        } else {\r\n            handleFetchError(res)\r\n        }\r\n    };\r\n\r\n    useEffect(() => { \r\n        /*\r\n         * The following is inferred from log statements: \r\n         * Suppose you are in React strict mode. Then, after useFetch has retured, and we have\r\n         * rendered for the first time:\r\n         * - the useEffect fires\r\n         * - the clean up function for this useEffect fires\r\n         * - isCancelled is set to true; and\r\n         * - the useEffect fires _again_ \r\n         * This second useEffect still reads vars native to the first render. So \r\n         * without setting isCancelled = false in the useEffect, fetchRetry would see \r\n         * isCancelled = true, and fail to make its dispatches. \r\n         */\r\n        isCancelled = false;\r\n        fetchRetry(totalFetchAttempts);\r\n        return () => {\r\n            isCancelled = true;\r\n            dispatch({type: INITIALISE});\r\n        }\r\n    }, deps);\r\n\r\n    return state;\r\n}\r\n\r\nexport default useFetch;      \r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}